{"ast":null,"code":"// Google OAuth helper functions for Business Profile integration\nimport { config } from './config';\nexport const GOOGLE_AUTH_BASE = \"https://accounts.google.com/o/oauth2/v2/auth\";\nexport const GOOGLE_TOKEN_URL = \"https://oauth2.googleapis.com/token\";\n\n/**\r\n * Scopes for Business Profile (locations + replies). Keep minimal to reduce review friction.\r\n * - https://www.googleapis.com/auth/business.manage\r\n * - openid email profile (optional convenience)\r\n */\nexport const GBP_SCOPES = config.scopes.join(\" \");\n\n/**\r\n * Build Google OAuth URL with proper scopes and offline access\r\n */\nexport function buildGoogleAuthUrl(state) {\n  const clientId = config.google.clientId;\n  const redirectUri = `${config.app.url}/oauth/callback`;\n  const params = new URLSearchParams({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: \"code\",\n    scope: GBP_SCOPES,\n    access_type: \"offline\",\n    // get refresh_token\n    prompt: \"consent\",\n    // force refresh_token on repeat connects\n    include_granted_scopes: \"true\",\n    state\n  });\n  return `${GOOGLE_AUTH_BASE}?${params.toString()}`;\n}\n\n/**\r\n * Exchange authorization code for access and refresh tokens\r\n */\nexport async function exchangeCodeForTokens(code) {\n  const clientId = config.google.clientId;\n  const clientSecret = config.google.clientSecret;\n  const redirectUri = `${config.app.url}/oauth/callback`;\n  const body = new URLSearchParams({\n    code,\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: \"authorization_code\"\n  });\n  try {\n    const res = await fetch(GOOGLE_TOKEN_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      body\n    });\n    if (!res.ok) {\n      const errorText = await res.text();\n      throw new Error(`Token exchange failed: ${errorText}`);\n    }\n    return await res.json();\n  } catch (error) {\n    console.error('Token exchange error:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Refresh access token using refresh token\r\n */\nexport async function refreshAccessToken(refreshToken) {\n  const clientId = config.google.clientId;\n  const clientSecret = config.google.clientSecret;\n  const body = new URLSearchParams({\n    client_id: clientId,\n    client_secret: clientSecret,\n    refresh_token: refreshToken,\n    grant_type: \"refresh_token\"\n  });\n  try {\n    const res = await fetch(GOOGLE_TOKEN_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      body\n    });\n    if (!res.ok) {\n      const errorText = await res.text();\n      throw new Error(`Refresh failed: ${errorText}`);\n    }\n    return await res.json();\n  } catch (error) {\n    console.error('Token refresh error:', error);\n    throw error;\n  }\n}\n\n/**\r\n * Generate a random state string for CSRF protection\r\n */\nexport function generateState() {\n  const randomBytes = new Array(24).fill(0).map(() => Math.floor(Math.random() * 256));\n  return randomBytes.map(b => b.toString(16).padStart(2, '0')).join('');\n}\n\n/**\r\n * Store Google tokens in localStorage (for demo purposes)\r\n * In production, these should be stored securely on the server\r\n */\nexport function storeGoogleTokens(tokens) {\n  const tokenData = {\n    access_token: tokens.access_token,\n    refresh_token: tokens.refresh_token,\n    expires_in: tokens.expires_in,\n    scope: tokens.scope,\n    token_type: tokens.token_type,\n    expiry_date: Date.now() + tokens.expires_in * 1000\n  };\n  localStorage.setItem('google_tokens', JSON.stringify(tokenData));\n  localStorage.setItem('google_connected', 'true');\n}\n\n/**\r\n * Get stored Google tokens\r\n */\nexport function getGoogleTokens() {\n  const stored = localStorage.getItem('google_tokens');\n  if (!stored) return null;\n  try {\n    return JSON.parse(stored);\n  } catch (error) {\n    console.error('Error parsing stored tokens:', error);\n    return null;\n  }\n}\n\n/**\r\n * Check if Google is connected\r\n */\nexport function isGoogleConnected() {\n  return localStorage.getItem('google_connected') === 'true';\n}\n\n/**\r\n * Clear Google tokens (for disconnect)\r\n */\nexport function clearGoogleTokens() {\n  localStorage.removeItem('google_tokens');\n  localStorage.removeItem('google_connected');\n}\n\n/**\r\n * Check if access token is expired or expires soon\r\n */\nexport function isTokenExpired(tokens) {\n  if (!tokens || !tokens.expiry_date) return true;\n\n  // Consider expired if expires within 2 minutes\n  const buffer = 2 * 60 * 1000; // 2 minutes in milliseconds\n  return Date.now() + buffer >= tokens.expiry_date;\n}\n\n/**\r\n * Get valid access token, refreshing if necessary\r\n */\nexport async function getValidAccessToken() {\n  const tokens = getGoogleTokens();\n  if (!tokens) return null;\n  if (isTokenExpired(tokens) && tokens.refresh_token) {\n    try {\n      const refreshed = await refreshAccessToken(tokens.refresh_token);\n      const newTokens = {\n        ...tokens,\n        access_token: refreshed.access_token,\n        expires_in: refreshed.expires_in,\n        expiry_date: Date.now() + refreshed.expires_in * 1000\n      };\n      storeGoogleTokens(newTokens);\n      return refreshed.access_token;\n    } catch (error) {\n      console.error('Failed to refresh token:', error);\n      // Return old token, let the API call fail if it's truly expired\n      return tokens.access_token;\n    }\n  }\n  return tokens.access_token;\n}","map":{"version":3,"names":["config","GOOGLE_AUTH_BASE","GOOGLE_TOKEN_URL","GBP_SCOPES","scopes","join","buildGoogleAuthUrl","state","clientId","google","redirectUri","app","url","params","URLSearchParams","client_id","redirect_uri","response_type","scope","access_type","prompt","include_granted_scopes","toString","exchangeCodeForTokens","code","clientSecret","body","client_secret","grant_type","res","fetch","method","headers","ok","errorText","text","Error","json","error","console","refreshAccessToken","refreshToken","refresh_token","generateState","randomBytes","Array","fill","map","Math","floor","random","b","padStart","storeGoogleTokens","tokens","tokenData","access_token","expires_in","token_type","expiry_date","Date","now","localStorage","setItem","JSON","stringify","getGoogleTokens","stored","getItem","parse","isGoogleConnected","clearGoogleTokens","removeItem","isTokenExpired","buffer","getValidAccessToken","refreshed","newTokens"],"sources":["C:/Users/Qlirim Elezi/Desktop/ReviewPilot/ReviewPilot/frontend/src/google-oauth.js"],"sourcesContent":["// Google OAuth helper functions for Business Profile integration\r\nimport { config } from './config';\r\n\r\nexport const GOOGLE_AUTH_BASE = \"https://accounts.google.com/o/oauth2/v2/auth\";\r\nexport const GOOGLE_TOKEN_URL = \"https://oauth2.googleapis.com/token\";\r\n\r\n/**\r\n * Scopes for Business Profile (locations + replies). Keep minimal to reduce review friction.\r\n * - https://www.googleapis.com/auth/business.manage\r\n * - openid email profile (optional convenience)\r\n */\r\nexport const GBP_SCOPES = config.scopes.join(\" \");\r\n\r\n/**\r\n * Build Google OAuth URL with proper scopes and offline access\r\n */\r\nexport function buildGoogleAuthUrl(state) {\r\n  const clientId = config.google.clientId;\r\n  const redirectUri = `${config.app.url}/oauth/callback`;\r\n  \r\n  const params = new URLSearchParams({\r\n    client_id: clientId,\r\n    redirect_uri: redirectUri,\r\n    response_type: \"code\",\r\n    scope: GBP_SCOPES,\r\n    access_type: \"offline\",     // get refresh_token\r\n    prompt: \"consent\",          // force refresh_token on repeat connects\r\n    include_granted_scopes: \"true\",\r\n    state,\r\n  });\r\n  \r\n  return `${GOOGLE_AUTH_BASE}?${params.toString()}`;\r\n}\r\n\r\n/**\r\n * Exchange authorization code for access and refresh tokens\r\n */\r\nexport async function exchangeCodeForTokens(code) {\r\n  const clientId = config.google.clientId;\r\n  const clientSecret = config.google.clientSecret;\r\n  const redirectUri = `${config.app.url}/oauth/callback`;\r\n\r\n  const body = new URLSearchParams({\r\n    code,\r\n    client_id: clientId,\r\n    client_secret: clientSecret,\r\n    redirect_uri: redirectUri,\r\n    grant_type: \"authorization_code\",\r\n  });\r\n\r\n  try {\r\n    const res = await fetch(GOOGLE_TOKEN_URL, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n      body,\r\n    });\r\n    \r\n    if (!res.ok) {\r\n      const errorText = await res.text();\r\n      throw new Error(`Token exchange failed: ${errorText}`);\r\n    }\r\n    \r\n    return await res.json();\r\n  } catch (error) {\r\n    console.error('Token exchange error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Refresh access token using refresh token\r\n */\r\nexport async function refreshAccessToken(refreshToken) {\r\n  const clientId = config.google.clientId;\r\n  const clientSecret = config.google.clientSecret;\r\n  \r\n  const body = new URLSearchParams({\r\n    client_id: clientId,\r\n    client_secret: clientSecret,\r\n    refresh_token: refreshToken,\r\n    grant_type: \"refresh_token\",\r\n  });\r\n  \r\n  try {\r\n    const res = await fetch(GOOGLE_TOKEN_URL, {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n      body,\r\n    });\r\n    \r\n    if (!res.ok) {\r\n      const errorText = await res.text();\r\n      throw new Error(`Refresh failed: ${errorText}`);\r\n    }\r\n    \r\n    return await res.json();\r\n  } catch (error) {\r\n    console.error('Token refresh error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate a random state string for CSRF protection\r\n */\r\nexport function generateState() {\r\n  const randomBytes = new Array(24).fill(0).map(() => Math.floor(Math.random() * 256));\r\n  return randomBytes.map(b => b.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\n/**\r\n * Store Google tokens in localStorage (for demo purposes)\r\n * In production, these should be stored securely on the server\r\n */\r\nexport function storeGoogleTokens(tokens) {\r\n  const tokenData = {\r\n    access_token: tokens.access_token,\r\n    refresh_token: tokens.refresh_token,\r\n    expires_in: tokens.expires_in,\r\n    scope: tokens.scope,\r\n    token_type: tokens.token_type,\r\n    expiry_date: Date.now() + (tokens.expires_in * 1000)\r\n  };\r\n  \r\n  localStorage.setItem('google_tokens', JSON.stringify(tokenData));\r\n  localStorage.setItem('google_connected', 'true');\r\n}\r\n\r\n/**\r\n * Get stored Google tokens\r\n */\r\nexport function getGoogleTokens() {\r\n  const stored = localStorage.getItem('google_tokens');\r\n  if (!stored) return null;\r\n  \r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch (error) {\r\n    console.error('Error parsing stored tokens:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if Google is connected\r\n */\r\nexport function isGoogleConnected() {\r\n  return localStorage.getItem('google_connected') === 'true';\r\n}\r\n\r\n/**\r\n * Clear Google tokens (for disconnect)\r\n */\r\nexport function clearGoogleTokens() {\r\n  localStorage.removeItem('google_tokens');\r\n  localStorage.removeItem('google_connected');\r\n}\r\n\r\n/**\r\n * Check if access token is expired or expires soon\r\n */\r\nexport function isTokenExpired(tokens) {\r\n  if (!tokens || !tokens.expiry_date) return true;\r\n  \r\n  // Consider expired if expires within 2 minutes\r\n  const buffer = 2 * 60 * 1000; // 2 minutes in milliseconds\r\n  return Date.now() + buffer >= tokens.expiry_date;\r\n}\r\n\r\n/**\r\n * Get valid access token, refreshing if necessary\r\n */\r\nexport async function getValidAccessToken() {\r\n  const tokens = getGoogleTokens();\r\n  \r\n  if (!tokens) return null;\r\n  \r\n  if (isTokenExpired(tokens) && tokens.refresh_token) {\r\n    try {\r\n      const refreshed = await refreshAccessToken(tokens.refresh_token);\r\n      const newTokens = {\r\n        ...tokens,\r\n        access_token: refreshed.access_token,\r\n        expires_in: refreshed.expires_in,\r\n        expiry_date: Date.now() + (refreshed.expires_in * 1000)\r\n      };\r\n      \r\n      storeGoogleTokens(newTokens);\r\n      return refreshed.access_token;\r\n    } catch (error) {\r\n      console.error('Failed to refresh token:', error);\r\n      // Return old token, let the API call fail if it's truly expired\r\n      return tokens.access_token;\r\n    }\r\n  }\r\n  \r\n  return tokens.access_token;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}